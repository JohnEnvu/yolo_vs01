1. 嵌入式设备文件
# gpio
## gpio的模式，gpio可以指定模式
i，o

## gpio的操作
echo I > /dev/gpio25
知道设备节点之后直接echo就能操作电平

echo O1 > /dev/gpio25
这里是O不是零
是out 1的意思
O要大写，小写不行

读输出
cat /dev/gpio25
### 命令行手动将gpi拉低后cat看到还是0 现象解读
如果 Pin 25 在板子上被设计成了“开漏输出”或者外部接了很强的下拉电阻：
软件设置 O1 只是闭合了内部的一个开关。
如果外部负载太重，电压会被直接拽到 0V 。

还有我物理重启不会格式化，是因为我关的开关是测试架mcu的，mcu重启会输出一个高电平，而板端终端reboot测试架因为没有重启，就不会输出高电平，所以当板端gpi检测到是低电平的时候就触发格式化

### 板端gpi（25引脚）读到低电平格式化 的解决方案
1. 直接echo O1 > /dev/gpio25手动将gpi拉高失败，判断外部可能有强下拉电阻
2. 当前运行方式是mcu启动时会控制测试架将通道2的gpo拉高，输出高电平，所以物理重启（mcu和板端同时断电后上电）就不会触发初始化
3. 板端的gpi25物理连接测试架通道2gpo

解决方案
开机脚本中开机时用t8控制测试架同道2gpo一直输出高电平
设置成功与否能在测试架的数显屏上看到，in一栏的通道2
```bash
stty -F /dev/ttyS0 115200 2>/dev/null  
sleep 0.1
# T8 指令：控制测试架 Channel 2 (Pin 25) 输出高电平
# 结构：Head(E8 FB) + Cmd(01) + Res(00) + Seq(00 01) + Len(00 08) + Mask(00 00 00 04) + Status(00 00 00 04) + Pad(00) + Checksum(1B)
echo -e -n "\xe8\xfb\x01\x00\x00\x01\x00\x08\x00\x00\x00\x04\x00\x00\x00\x04\x00\x1b" > /dev/ttyS0
```
### 测试程序报错 Error: Failed to read Board GPI pin 25
1. 两种设备节点的控制方式
方式 A：标准 sysfs 方式 ( /sys/class/gpio/gpioX )
原理 ：Linux 内核自带的标准驱动。
特点 ：通过读写文本文件（如 direction 、 value ）来控制。
现状 ：这种方式最通用，但可能不支持您的自定义协议（比如您提到的 O1 、 I 这种特定字符指令）。

B：自定义字符设备方式 ( /dev/gpioX )
原理 ：厂家或您自己编写的特定驱动程序。
特点 ：直接操作设备文件，支持特殊指令（如写入 I 切换输入，写入 O1 输出高电平）。
现状 ：这是您目前测试程序依赖的方式，也是最有效的方式。

为什么会产生冲突？
内核对硬件资源的保护遵循 “先占原则” ：
1. 当脚本执行 echo 25 > export 时， 方式 A 占用了硬件 GPIO 25。
2. 当您的测试程序尝试打开 /dev/gpio25 时， 方式 B 的驱动会尝试向内核申请控制 GPIO 25。
3. 内核发现 GPIO 25 已经被 方式 A 拿走了，于是报错 gpio25 request failed （申请失败）。
4. 结果就是：您想用更高级的 /dev/gpio25 ，但由于 /sys/class/gpio/gpio25 已经开着门，导致前者进不去。

### 之前的写法为什么会导致占用？
cho 25 > /sys/class/gpio/export
一旦执行了这句，内核就标记：“GPIO 25 现在归 sysfs 驱动管了
当您的 C++ 程序运行并尝试调用 open("/dev/gpio25", ...) 时，内核会检查硬件。由于它已经被 sysfs “预订”了，内核为了防止两个驱动互相打架（比如一个想写 1，一个想写 0），就会拒绝 /dev/gpio25 的请求，抛出 request failed 

“开机之后还一直检测着吗？” 是的。 在您的业务逻辑中，Pin 25 往往被定义为一个“功能引脚”（如 Reset 键或状态监测）。系统中可能有一个后台进程（例如 kingdier 或某个监控守护进程）在 持续轮询 或通过 中断 监听这个引脚的电平。
如果这个引脚在任何时刻检测到持续的低电平，监控进程就会认为“用户按下了复位键”，从而执行 reboot 或格式化。
这就是为什么我们不仅要在开机时拉高，还要确保业务程序启动后能正确读取它。

简单来说就是
原来的脚本
echo 25 > /sys/class/gpio/export
登记25引脚到内核（sysfs），告诉内核：“我要通过 sysfs 这种方式来管 25 号引脚了。”
内核听到后，会创建 /sys/class/gpio/gpio25/ 这个目录
占用产生的原因 ：一旦登记了 sysfs 的门牌号，内核就不允许 /dev/gpio25 （专线驱动）再来登记，这就是冲突的由来
冗余的，实际上没什么用

但是这不是核心的问题，改了之后问题仍然存在

### 之前的写法为什么会导致占用？ - 进一步判断解决
这是个之前遗留的老问题，我之前是用来dev+sysfs的，删掉sysfs就报错，所以之前不出现这个问题是有sysfs的双重保险帮我修复了，但是现在代码优化之后要去掉sysfs，就得找出这个问题是什么导致的，以及怎么解决

1. 问题背景与现象
- 系统重启风险 ：Pin 25 在板端具有特殊功能（通常关联硬件复位或格式化监听）。一旦该引脚在系统启动或运行过程中被拉低，会导致系统意外进入重启或初始化流程。
- 程序运行卡死 ：在执行 GPIO 输入测试时，程序运行到 Pin 25 读取环节突然卡住，随后报错 READ_FAILED 。
- 资源冲突 ：多次尝试通过 sysfs (export/unexport) 释放引脚，但依然无法稳定读取。

2. 核心原因分析
- 字符设备驱动的阻塞特性 ：
  - 自定义的 /dev/gpioX 驱动在返回电平值（'0' 或 '1'）时，并未追加换行符 ( \n )。
  - C++ 高级流操作（如 std::getline 或 >> 运算符）在读取时会持续寻找换行符或文件结束符 (EOF)。由于驱动层没有这些标志，程序会陷入无限期阻塞。
- 回退逻辑的隐患 ：
  - 旧代码在 /dev/gpioX 失败时会自动切换到 sysfs 模式。这种“自动补漏”虽然有时能读到数据，但频繁的 export/unexport 操作会与硬件驱动产生严重的资源竞争，这也是导致系统不稳定的诱因之一。
- 硬件逻辑关联 ：
  - Pin 25 的物理状态直接决定了系统的运行模式，必须确保在任何时刻（尤其是启动初期和测试切换期）该引脚都有稳定的高电平输入。

3. 最终解决方案
A. 启动预保护 (Shell 脚本优化)
- 提前介入 ：在 opt.sh 的最早期阶段，通过 T8 协议 强制控制测试架 Channel 2 输出高电平。
- 本地配置 ：在业务启动前，通过 /dev/gpio25 写入 "I" 指令将其设为输入模式，并清理所有 sysfs 的残留导出，确保自定义驱动独占该引脚。
B. 驱动层读取优化 (C++ 代码重构)
- 低级 I/O 替代流操作 ：在 GpioDriver.cpp 中弃用 std::ifstream ，改用系统调用：
  - 使用 open(O_RDWR) 打开设备。
  - 使用 write(fd, "I", 1) 实时切换输入模式。
  - 使用 lseek(fd, 0, SEEK_SET) 配合 read(fd, &char, 1) 直接抓取原始字节。
  - 效果 ：这种方式不再等待换行符，只要驱动有数据即刻返回，彻底解决了卡死问题。
- 引入互斥锁 ：在 GpioDriver.h 增加 std::mutex ，确保在多线程或高频测试下对同一 GPIO 节点的访问是线程安全的。
C. 逻辑链路闭环
- 取消 Sysfs 依赖 ：移除 getValue 内部的所有 unexport 逻辑，消除应用层与内核层不必要的资源抢夺，使读取链路更加纯净。

4. 修复成果
- 稳定性 ：解决了因引脚电平波动导致的系统重启问题。
- 鲁棒性 ：GPIO 读取操作响应迅速，不再受换行符缺失的影响。
- 安全性 ：通过互斥锁规避了并发操作导致的文件描述符异常。

## 设备文件的路径
/dev/gpio25

### 板端的信息，以及和测试架的连接细节
1. gpi
gpio25
应该是外部强制拉低了，直接echo设置不了高电平
连接测试架的通道2

2. gpo
顺序依次对应测试架的通道0-4
27
31
52
53
93

gpio23
这个是反相的，O0是高电平，O1是低电平
对应测试架通道5

### 测试架通道号和实际物理连接的关系
1. 就是json中请求的通道号和引脚号，是不是要和实际的物理接线匹配的？
比如通道0对应引脚27
2. 要是json中对不上还能成功，就是在代码中硬编码了

## 代码逻辑修复
我做了一组测试，放了两个问题
两个引脚请求同一个通道号
一个引脚请求不存在的通道号（实际只有0-5通道实现了，但是我请求了6）
测试结果是全部通过，这里问题就很大了，针对json中非法参数的处理不到位

业务中的检测逻辑
针对问题一，两个引脚用同一个通道号
因为你请求了两个引脚（23 和 27）都对应通道 0，只要其中 任意一个 引脚物理上连接到了测试架的通道 0 并成功拉高，测试架就会报告“通道 0 是高电平”。
当前的逻辑 无法识别“多对一”的错误映射 ，它只关心“我要的那个通道有没有变高”，而不关心是谁把它拉高的。

针对问题二，JSON 中乱填了引脚与通道的对应关系，但依然返回 pass
T8 查询的局限性 ：测试架返回的是 当前所有 高电平通道的集合。当前的业务逻辑没有去验证“不该变高的通道是否依然是低的”。

目前的 pass 标准
GPO ： iGPO 引脚输出 1 → T8 查询测试架 iChn 对应的位是否为 1。
GPI ：T8 控制测试架 iChn 输出 1 → 读取板端 iGPI 物理电平是否为 1。
# 串口ttys
## 板端串口情况
查看串口节点
ls /dev/ttyS*
/dev/ttyS0  /dev/ttyS1  /dev/ttyS4  /dev/ttyS5

串口2，测试串口，连接电脑的终端
和测试架连接的串口0
822a就两个串口

## 串口操作
用串口发送t8
echo -e -n "\xe8\xfb\x01\x00\x00\x01\x00\x08\x00\x00\x00\x04\x00\x00\x00\x04\x00\x1b" > /dev/ttyS0
这条命令作用是将测试架通道2的gpo拉高
用来解决板端gpi读到低电平会初始化的问题

# 系统启动
在 Linux 系统中， reboot 是软重启。系统重新引导后，内核加载完成，会按照启动序列执行 /etc/init.d/ 或 /data/cfg/ 下的启动脚本。
在每次开机（无论是断电重启还是 reboot 指令）时都会运行。

# adc
## 要是设备没识别到外设节点
驱动未加载
先根据源码和json中的两个设备关键词寻找
find -name "*adc*"
find -name "*saradc*"
将输出的内容给ai

得到结论：驱动未加载
在您的 find 输出中，虽然看到了驱动文件和硬件节点，但 /dev/ 目录下确实缺少 rv11x-adc 节点 ：
- 驱动文件存在 ： ./opt/ko/rv11x-adc.ko
- 测试工具存在 ： ./mnt/rk1126_adc_test
- 硬件平台节点存在 ： ./sys/bus/platform/devices/ff5e0000.saradc
- 缺失关键节点 ：在 /dev/ 下找不到任何名为 rv11x-adc 或 saradc 的字符设备节点。
结论 ：板端当前的 ADC 驱动（那个支持 ioctl 的自定义驱动 rv11x-adc.ko ） 没有被加载 。

尝试加载驱动
insmod /opt/ko/rv11x-adc.ko
报错
/opt/ko/rv11x-adc.ko
[  414.354228] rv11x_adc: Unknown symbol ring_buffer_read (err -2)
...
ai回复
从报错信息 Unknown symbol ring_buffer_read 可以看到， rv11x-adc.ko 依赖于一个名为 ring_buffer 的内核模块。这就是为什么单独 insmod 它会失败。

寻找内核模块
find /opt/ko -name "*ring_buffer*"
输出
/opt/ko/imagin_ring_buffer.ko

之后启动两个驱动
insmod /opt/ko/imagin_ring_buffer.ko
insmod /opt/ko/rv11x-adc.ko

在dev下成功找到设备节点
root@IM_R1K2:/# ls dev/
rv11x-adc
...
## ad校正算法
### 电压校正，双点校正
ad校正：将adc值转换成正确的电压值
是adc值与电压值的正确映射

原始值: adc驱动采集到的原始数据
校正值: 使⽤原始值、校正系数计算的结果，其中电流通道得到电流值、电压通道得到电压值
物理值: 使⽤校正值、传感器转换参数计算的结果，其中交流电流通道为有效值，直流电流通道和电压通道为瞬时值

y = (x - zero) * slope
校正值 = （原始值 - 偏移量）* 比例系数（一个adc刻度单位代表多少物理值）
iZer 定义 ：现在 iZer 明确存储的是 0V/0mA 时的 ADC 原始刻度值 ，而不再是物理偏移量。

双点校正过程
测试架输出0v
得到偏移量

测试架输出4.5v
slope = （4500 - 0）/（adc2 - adc1）
得到一个adc刻度代表多少物理值

这里的思路其实是，得到两个点的adc值和电压值，电压值是指定好的
然后d电压值/d adc值 = 比例系数，即一刻度adc值代表多少电压


这里有个电压互感器和电流互感器的注意点，但是我还没搞明白

### 输出结果解读
1. 关于电流结果（真实值 vs 默认值）
结论 ：您看到的电流 fSlp: "1.7730" 确实是 默认值 。

- 原因 ：目前电流校正采用的是“单点校零”法。它只通过测量 0mA 时的 ADC 原始值来确定 iZer （零位刻度），而斜率 fSlp 是直接从配置文件（ test_ad.json ）中读取的预设值。
- 改进 ：我已经修改了 LibAdc.cpp ，在电流校正成功后，会在 sErr 字段中显式提示： "Warning: Using default slope for current calibration (single point)" 。这样您一眼就能分辨出斜率是否经过实际测量。

2. 关于电压验证不通过（Std=3000, Actual=2960）
从数据上看，虽然计算值（2960mV）非常接近 3V，但超出了 MaxErr=30 （1%误差范围）的限制。这种情况通常由以下原因导致：
- 硬件/测试架波动 ：
  - 校正时使用的是 0V 和 4.5V 两个点。
  - 验证时测试架输出 3V。如果测试架在输出 3V 时存在约 1.3% 的偏差（实际可能只输出了 2960mV 左右），或者板端 ADC 在中间量程的线性度稍差，就会导致验证失败。
- 算法对齐检查 ：
  - 我核对了代码，验证逻辑 LibAdc.cpp:L217-223 使用的是 actualV = (adcV - zero) * slope 。
  - 这个逻辑与校正逻辑完全对齐。
- 建议 ：
  - 放宽阈值 ：如果硬件线性度如此，可以考虑将 test_ad.json 中的 fErrRange 从 0.01 (1%) 适当放宽到 0.02 (2%)。
  - 多次采样 ：目前读取 ADC 是单次读取，可能会受瞬时噪声影响。后续可以考虑在校正和验证时增加均值滤波（例如连续读 10 次取平均）。

算法是个很实在的东西，输入什么就会固定输出什么，不会因为环境的变化而改变，和硬件不一样，这就是软件的魅力，也是数学的魅力

## 注意板端的adc
有一块822a的电流通道是有问题的

## 关于ad校正系数的解读
当前的adc指电压通道adc
也就是ad校正之后得到的都是电压值

电流测试中要将得到的有效电压值转换成电流值，传感器参数是1v5A
电压校正参数和电流校正参数是一样的
或者换一种说法更准确
电压通道校正参数和电流通道校正参数物理含义上是一样的，都是adc刻度值和电压值转换的映射关系

### 关于电流测试中读到的电流值是600ma，理论输出应该是1000ma的问题复盘
当前已解决，问题出在板子上，板子的偏置电流太大了，正常板子是511，这块板子是575

算法处理过程
1s采样500个adc点，交流电，正弦波形
输出1个最终验证物理值，但在处理中分成了50个周期（每周期10个点）进行计算

对每一个点的处理：
减去偏置对应的adc刻度，这个刻度就是电流通道ad校正时候的零值（cp.zero）

对每10个点（一个周期/20ms）的处理：
将减去偏置后的每一个点，使用rms算法。
每一个值先平方，然后累加求和，然后取平均值，之后开根，得到一个值代表这十个点（一个周期）的有效ADC刻度（rmsRaw）。
之后一共得到50个周期的物理值

将每一段的有效ADC刻度（rmsRaw）输入到AD校正公式中：
voltage = rmsRaw * cp.slope
从校正公式输出电压值（mV）。

将电压值使用json中传入的物理值计算公式：
phyValue = abs(voltage * fPhySlope + fPhyZero)
其中物理值转换系数 fPhySlope 默认是5，因为对应的传感器参数是1v5a，电压和电流的转换比是1：5。
注意：电流测试为交流信号，严禁使用补偿值，结果直接通过变比和物理零点换算。
最后进行输出限幅保护，确保结果在 [fPhyOutMin, fPhyOutMax] 范围内。
最终将50个周期的物理值取平均并四舍五入，得到最终电流值（mA）。

完整总结
电流测试的算法细节如下，重点展示了 RMS（均方根）计算 、 平均值处理 以及 限幅保护 的具体触发时机：
1. 原始采样阶段 (Raw Sampling)
    - 动作 ：在 1 秒内采集 500 个 ADC 原始点 。
    - 结构 ：这 500 个点被分为 50 个周期 （Interval），每个周期包含 10 个点 （对应 50Hz 交流电的 20ms 周期）。
2. 周期内 RMS 计算 (Intra-period Processing)
    对这 10 个点 （一个周期）进行以下处理：
    1. 偏置消除 ：每个点先减去 AD 校正得到的零位刻度 cp.zero 。
    - diff = rawAdc - cp.zero
    2. 平方累加 ：计算这 10 个点的平方和。
    - sumSquare += diff * diff
    3. 周期平均与开根 ：
    - 计算平均平方值： avgSquare = sumSquare / 10
    - 开根号得到该周期的有效 ADC 刻度： rmsRaw = sqrt(avgSquare)
3. 物理值转换阶段 (Physical Conversion)
    对每一个周期得到的 rmsRaw 进行物理映射：

    1. 电压转换 ：将 ADC 刻度转为电压。
    - voltage = rmsRaw * cp.slope (单位：mV)
    2. 物理值换算 ：将电压转为电流。
    - phyValue = abs(voltage * fPhySlope + fPhyZero) (单位：mA)
    - 注意 ：此处 不使用 补偿值。
4. 限幅与最终平均 (Limiting & Final Average)
    1. 第一次限幅 (输出限幅保护) ：
    - 时机 ：在每个周期算完物理值 phyValue 后。
    - 动作 ：如果 phyValue 超过 fPhyOutMax 或低于 fPhyOutMin ，则将其截断到量程边界。
    - 意义：防止单个周期的异常波动导致结果严重偏离正常范围。
    2. 第二次平均 (周期平均) ：
    - 动作 ：将 50 个周期处理后的 phyValue 进行累加，最后除以 50，得到总的平均物理值。
    3. 取整处理 ：
    - 对最终的平均值进行四舍五入，得到最终显示的电流值（mA）。
5.   总结：限幅与平均的时机
    - 平均 (Average) 发生了两次：
    1. 第一次 ：在每个周期内（10个点），用于计算该周期的 RMS 有效值。
    2. 第二次 ：在所有周期结束后（50个周期），用于平滑测量结果，输出最终验证值。
    - 限幅 (Limiting) 发生了一次：
    1. 唯一一次 ：在每个周期物理值计算完成 后 、计入总平均值 前 。

# ai使用技巧
让ai回答时使用纯文本格式，并记录到你的记忆中

- **AI 协作原则 (核心红线)**:
- **禁止编译**：AI 当前运行的环境与用户编译环境（VM）不一致，**严禁在终端执行 `make` 或任何编译/运行指令**。
- **职责定位**：AI 仅负责通过代码审计发现逻辑漏洞、修复 Bug、优化架构以及维护配置文件。
- **验证方式**：所有代码变更需由用户在其实际环境下进行编译验证。AI 需确保代码逻辑严密、语法正确且符合上下文约定。
- **兼容性与灵活性**：
- **去硬编码**：严禁在 C++ 逻辑中硬编码特定板卡的驱动路径（如 `insmod /opt/ko/...`）。
- **报错优先**：当硬件环境不匹配时（如节点缺失），应通过清晰的报错信息提示用户手动处理，而不是尝试自动修复，以确保代码在不同硬件版本间的通用性。
- **配置驱动**：所有设备节点、通道参数应通过 JSON 配置文件灵活指定。
- **文档规范**：在记录公式或技术说明时，**必须使用纯文本格式**（如 y = k * x + b），严禁使用 LaTeX、MathJax 等特殊数学符号格式，确保在所有编辑器和终端中均能清晰阅读。

# 音频采样与ffmpeg播放
## 怎么播放g711a音频
转码成wav
ffmpeg -f alaw -ar 16000 -ac 1 -i "C:\lxt\svn_study\step02\tmp\2-0.g711a" test.wav
播放
ffplay test.wav

## 格式转换之后播放的音频不太对劲
像是开了倍速一样，而且时长也不一样，我请求的json是录制5s，播放的时候我听着像是把信息都压缩到前2s，然后后面很长一段的空白，是怎么回事？

ffmpeg转码时候的采样率不对，采样率高了
json中的采样率是8000，ffmpeg转换的时候用的是16000
ffmpeg -f alaw -ar 8000 -ac 1 -i "C:\lxt\svn_study\step02\tmp\6-0.g711a" test.wav
ffplay test.wav
倍速问题解决了
主要是采样率问题

## 格式转换之后，在有效信息之后有长时间的空白，是什么问题？
问题本质 ：原来的代码在录音线程一启动时就记录了 startTime 。但实际上，从线程启动到 RKMedia 硬件完成初始化、AI 开启、AENC 编码器准备就绪并吐出第一帧数据，中间存在明显的硬件准备延迟。

### 解决“时长不准”：纳秒级高精度控制
- 问题本质 ：之前使用 ts.tv_sec 是整数秒。在循环运行过程中，整数减法会丢失掉毫秒部分的精度。例如，当实际运行了 4.99 秒时，整数减法可能判定还没到 5 秒，但下一圈循环可能就跳到了 5.1 秒，或者因为边界判定问题在 4.35 秒时就提前退出了。
- 逻辑实现 ：
  - 将计时变量改为 double 类型。
  - 使用公式 currentTime = ts.tv_sec + (double)ts.tv_nsec / 1e9 将秒和纳秒合并。
  - 判定条件改为 if (currentTime - startTime >= (double)ctx->iDuration) 。
- 结果 ：计时精度从“秒级”提升到了“纳秒级”。这保证了程序会在距离 5.000s 最近的一个循环周期内停止录制，误差控制在毫秒级（通常取决于音频帧的采样间隔）。

3. 解决“倍速感”：采样率对齐与阻塞读取
- 问题本质 ：
  - 倍速感 ：通常是录制时设置的采样率（如 16000Hz）与播放时指定的采样率（如 8000Hz）不匹配，导致声音听起来像快放。
  - 数据丢失 ：之前如果使用非阻塞读取，在系统繁忙时可能会漏掉帧。
- 逻辑实现 ：
  - 阻塞读取 ：在 RkAudio.cpp:L155 中使用 -1 （阻塞模式）调用 GetMediaBuffer 。这意味着线程会挂起等待，直到硬件准备好一帧数据。这保证了 G.711a 原始流的完整性，不丢帧。
  - 参数校验 ：确保 setupAENC 中的 sampleRate 严格透传自 JSON 请求，不再使用硬编码。

总结流程
1. 启动 ：线程运行，进入循环。
2. 等待 ：阻塞等待硬件吐出第一帧音频。
3. 触发 ：收到第一帧，记录高精度起始时间（纳秒级）。
4. 循环 ：持续读取数据并写入文件，每帧结束后比对当前高精度时间差。
5. 结束 ：时间差 [ o bj ec tO bj ec t ] ≥ 请求时长，立即停止并打印 Actual: 5.00xs ，关闭文件。
这种逻辑确保了**“请求 5s = 采集 5s 数据 = 文件时长 5s”**。