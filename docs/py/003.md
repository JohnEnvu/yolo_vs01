1. py思路

# 设计模式
消息队列
面向对象
等等

# 面向对象 - py
```bash
参考https://blog.csdn.net/2302_79546368/article/details/149090999?ops_request_misc=elastic_search_misc&request_id=e8d300d4f48226de092f9b1298ae10e0&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-149090999-null-null.142^v102^pc_search_result_base9&utm_term=python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1
```
1. def __init__（self, content） - 构造函数
self是对象里的存储空间，放传进来的对象
self.data = content
2. 
完整示例
```python
class Police:
    """警察"""
    def __init__(self, name, role):
        self.name = name
        self.role = role
        if role == "队员":
            self.hit_points = 200
        else:
            self.hit_points = 500
    def show_status(self):
        """ 查看警察状态 """
        message = "警察{}的生命值为:{}".format(self.name, self.hit_points)
        print(message)
    def bomb(self, terrorist_list):
        """ 投炸弹，炸掉恐怖分子 """
        for terrorist in terrorist_list:
            terrorist.blood -= 200
            terrorist.show_status()
 
class Terrorist:
    """ 恐怖分子 """
    def __init__(self, name, blood=300):
        self.name = name
        self.blood = blood
    def shoot(self, police_object):
        """ 开枪射击某个警察 """
        police_object.hit_points -= 5
        police_object.show_status()
        self.blood -= 2
    def strafe(self, police_object_list):
        """ 扫射某些警察 """
        for police_object in police_object_list:
            police_object.hit_points -= 8
            police_object.show_status()
    def show_status(self):
        """ 查看恐怖分子状态 """
        message = "恐怖分子{}的血量值为:{}".format(self.name, self.blood)
        print(message)
 
def run():
    # 1.创建3个警察
    p1 = Police("小峰", "队员")
    p2 = Police("苑昊", "队员")
    p3 = Police("于超", "队长")
    # 2.创建2个匪徒
    t1 = Terrorist("alex")
    t2 = Terrorist("eric")
    # alex匪徒射击于超警察
    t1.shoot(p3)
    # alex扫射
    t1.strafe([p1, p2, p3])
    # eric射击苑昊
    t2.shoot(p2)
    # 小峰炸了那群匪徒王八蛋
    p1.bomb([t1, t2])
    # 小峰又炸了一次alex
    p1.bomb([t1])
if __name__ == '__main__':
    run()
```
## 封装，继承，多态
1. 同一类放一起，数据用__init__封装到对象中
2. 继承
```python
class Base:
    def func(self):
        print("Base.func")
 
class Son(Base):
    def show(self):
        print("Son.show")
        
s1 = Son()
s1.show()
s1.func() # 优先在自己的类中找，自己没有才去父类。对象到底是谁？优先就会先去谁里面找。
 
s2 = Base()
s2.func()
```