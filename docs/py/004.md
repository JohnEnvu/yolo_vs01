1. py基础

# 常识
1. 
_total = 100            # 下划线开头通常表示“内部使用”或“私有”
MAX_SIZE = 1024         # 全大写通常表示“常量”（固定不变的值）
calculate_area()        # 函数名，动词+名词
StudentInfo             # 类名，首字母大写（驼峰命名法）
__private_var           # 双下划线开头，有特殊含义
2. 多行注释
'''
注释内容
'''
4. 一行拆成多行
total = item_one + \
        item_two + \
        item_three
7. 
将整个模块(somemodule)导入，格式为： import somemodule
从某个模块中导入某个函数,格式为： from somemodule import somefunction
8. Python可以使用-h参数查看各参数帮助信息
9. py不用编译

## 数据类型
1. 
>>> 2 / 4  # 除法，得到一个浮点数
0.5
>>> 2 // 4 # 除法，得到一个整数
0
>>> 17 % 3 # 取余
2
>>> 2 ** 5 # 乘方
32
2. 可以通过 type() 函数查看变量的类型
此外还可以用 isinstance 来判断：
>>> a = 111
>>> isinstance(a, int)
True
3. 转义，输出特殊符号
>>> print(r'\n') 
输出 \n
4. complex 复数类型 - 实部和虚部

## 推导列表
1. 从一个数据序列构建另一个新的数据序列的结构体
### 列表推导 
```py
# 循环”列表“中的“变量”，满足“条件”就放进”表达式“中
# if可以不要的
[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]

# .upper() 方法将字符串转换为大写
过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：
>>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
>>> new_names = [name.upper()for name in names if len(name)>3]
>>> print(new_names)
['ALICE', 'JERRY', 'WENDY', 'SMITH']
```
### 字典推导
```py
{ key_expr: value_expr for value in collection if condition }

# 将列表中各字符串值为键，各字符串的长度为值，组成键值对
listdemo = ['Google','Runoob', 'Taobao']
>>> newdict = {key:len(key) for key in listdemo}
>>> newdict
{'Google': 6, 'Runoob': 6, 'Taobao': 6}
```
### 集合推导
```py
{ expression for item in Sequence if conditional }

# 计算数字 1,2,3 的平方数：
>>> setnew = {i**2 for i in (1,2,3)}
>>> setnew
{1, 4, 9}

# 判断不是 abc 的字母并输出：
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
>>> type(a)
<class 'set'>
```
### 元组推导式（生成器表达式）
1. 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。
```py
(expression for item in Sequence if conditional )
```
2. 和列表的区别
列表会立刻将数据生成，放进变量中
元组只是一个生成器模板，没有数据，在使用时才会生成数据，可以节省内存
>>> tuple(a) 
(1, 2, 3, 4, 5, 6, 7, 8, 9)
但是只能用一次，用完之后tuple(a) 就空了
变生成边读，读完就扔掉，不占内存
3. 元组和列表各自的使用场景
列表 - 数据小，反复使用修改
场景 A：数据需要反复访问 如果你生成的列表在后面要被多次循环读取（比如先求和，再找最大值，再打印），必须用列表推导式。因为列表推导式将数据存在内存里，可以反复读。
场景 B：数据量较小 当处理的数据量在几千、几万个以内，且内存压力不大时，列表推导式更直观，且支持索引（ list[0] ）和切片。
场景 C：需要立即得到结果 如果你接下来的代码逻辑依赖于“所有数据都已就绪”，那么就用列表。

元组 - 数据大，只使用一次，追求性能
场景 A：处理海量数据（大数据处理） 比如读取一个 10GB 的日志文件，或者生成 1 亿个数字。如果用列表，你的电脑内存会直接爆掉（OOM）。用生成器的话，内存占用几乎为 0，因为它一次只在内存里放一个数。
场景 B：只需要遍历一次 如果你写代码只是为了计算一个总和 sum(...) 或者做一个简单的 for 循环，循环完就不再需要这些数据了，生成器是最佳选择。
场景 C：作为函数的参数 很多 Python 内置函数（如 sum() , max() , min() , any() , all() ）都支持直接接收生成器

